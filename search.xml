<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Image as IMU</title>
      <link href="/2025/10/08/Image-as-IMU/"/>
      <url>/2025/10/08/Image-as-IMU/</url>
      
        <content type="html"><![CDATA[<p>这篇文章提出了从单张运动模糊图像中估计相机速度的方法，将模糊作为运动的线索而非噪声，此处的运动模糊是曝光时间内多个“虚拟图像”的叠加，其模糊轨迹可视为“虚拟光流”，蕴含了相机运动信息</p><hr><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>Image as an IMU: Estimating Camera Motion from a Single Motion-Blurred Image</p><p>文章来自2025ICCV，作者是Jerred Chen 和Ronald Clark，arxiv地址为</p><p><a href="https://arxiv.org/abs/2503.17358">[2503.17358] Image as an IMU: Estimating Camera Motion from a Single Motion-Blurred Image</a></p><h2 id="传统方法的问题"><a href="#传统方法的问题" class="headerlink" title="传统方法的问题"></a>传统方法的问题</h2><p>在机器人和VR&#x2F;AR应用中，相机快速移动会导致严重的<strong>运动模糊</strong>（motion blur）。这种模糊会破坏传统视觉里程计（VO）和运动恢复结构（SfM）方法所依赖的图像特征匹配，导致这些方法失效</p><p><strong>现有解决方案的缺陷</strong>：</p><ul><li><strong>丢弃模糊帧</strong>：简单粗暴，但是会丢失宝贵的运动信息。</li><li><strong>融合IMU</strong>：虽然有效，但引入了额外的硬件成本、复杂的传感器同步问题以及IMU固有的漂移误差（drift）</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p><strong>图像形成过程</strong>：在曝光时间 τ 内，相机不断移动，每个像素累积了来自不同场景点的光线。公式(1)给出了模糊图像 $I_B$​ 的积分定义。</p><p>$$<br>I_B &#x3D; g \int_{\tau_0}^{\tau} I_\nu(t) , dt<br>$$</p></li><li><p><strong>离散化近似</strong>：在实践中，将曝光时间离散化为 N 个瞬间，每个瞬间对应一个“虚拟图像” Iνi​。模糊图像是这些虚拟图像的平均。</p><p>$$<br>I_B \approx g \frac{1}{N} \sum_{i&#x3D;1}^{N} I_{\nu_i}<br>$$</p></li><li><p><strong>核心直觉</strong>：一张模糊图像可以被视为由多个“虚拟图像”叠加而成。这些虚拟图像之间的像素对应关系，就编码了相机的运动信息。</p></li><li><p><strong>虚拟对应关系</strong>：假设场景是刚性的，那么从第一个虚拟图像到最后一个虚拟图像  ${ I_{\nu_1}, \ldots, I_{\nu_N} }$，每个像素的位移就是一个“虚拟光流”。这个光流场直接关联到相机在曝光期间的相对运动。</p></li><li><p><strong>结合深度</strong>：如果再知道场景的深度 D，就可以将2D的像素运动（光流）与3D的相机运动联系起来，从而求解出完整的6DoF相对位姿。</p></li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Flow-and-Depth-Prediction-光流与深度预测"><a href="#Flow-and-Depth-Prediction-光流与深度预测" class="headerlink" title="Flow and Depth Prediction (光流与深度预测)"></a><strong>Flow and Depth Prediction (光流与深度预测)</strong></h3><ul><li><p><strong>网络架构</strong>：采用 <strong>SegNeXt</strong> 作为共享编码器，两个独立的解码器分别输出光流 F 和深度 D。</p></li><li><p><strong>光流定义</strong>：其中 p1​ 是第一个虚拟图像中的像素坐标，p2′​ 是同一3D点投影到最后一个虚拟图像中的坐标。</p><p>$$<br>F &#x3D; p’_2 - p_1<br>$$</p></li><li><p><strong>损失函数</strong>：</p><p>$$<br>L_1 &#x3D; \lambda_F |F - h_f(\hat{F}<em>{fw}, \hat{F}</em>{bw})| + \lambda_D |D - \hat{D}|<br>$$</p><ul><li><p>对光流和深度分别施加L1损失。</p></li><li><p>引入<strong>重定向函数</strong> hf​解决训练歧义。因为无法确定哪个虚拟图像是“开始”，所以标签 F 会被设定为与预测方向 F 更接近的那个真实方向（正向${F}<em>{fw}$ 或反向 ${F}</em>{bw}$​），确保训练稳定。</p><p>$$<br>h_f(\hat{F}<em>{fw}, \hat{F}</em>{bw}; F) &#x3D;</p></li></ul></li></ul><p>\begin{cases}<br>\hat{F}<em>{fw}, &amp; \text{if } \langle \hat{F}</em>{fw}, F \rangle &gt; \langle \hat{F}<em>{bw}, F \rangle \<br>\hat{F}</em>{bw}, &amp; \text{otherwise}<br>\end{cases}<br>    $$</p><h3 id="Differentiable-Velocity-Computation-可微分速度计算"><a href="#Differentiable-Velocity-Computation-可微分速度计算" class="headerlink" title="Differentiable Velocity Computation (可微分速度计算)"></a><strong>Differentiable Velocity Computation (可微分速度计算)</strong></h3><ul><li><strong>理论依据</strong>：采用Trucco and Verri的运动场方程，该方程建立了像素运动 (Fx​,Fy​)、深度 d、焦距 f 和相机6DoF运动 (θx​,θy​,θz​,tx​,ty​,tz​) 之间的数学关系。<br>$$<br>F_x &#x3D; \frac{t_z p_x - t_x f}{d}</li></ul><ul><li>\theta_y f + \theta_z p_y</li></ul><ul><li>\frac{\theta_x p_x p_y}{f}</li></ul><ul><li>\frac{\theta_y p_x^2}{f}<br>$$<br>$$<br>F_y &#x3D; \frac{t_z p_y - t_y f}{d}</li></ul><ul><li>\theta_x f - \theta_z p_x</li></ul><ul><li>\frac{\theta_y p_x p_y}{f}</li></ul><ul><li>\frac{\theta_x p_y^2}{f}<br>$$</li></ul><ul><li><p><strong>线性系统</strong>：将运动场方程改写为标准的线性形式 Ax&#x3D;b（公式8和9）。</p><ul><li><p>A 矩阵由像素坐标、深度和焦距构成。</p><p>$$<br>A &#x3D;</p></li></ul></li></ul><p>\begin{bmatrix}<br>-\frac{f}{d} &amp; 0 &amp; \frac{p_x}{d} &amp; \frac{p_x p_y}{f} &amp; -\frac{p_x^2 + f^2}{f} &amp; p_y \<br>0 &amp; -\frac{f}{d} &amp; \frac{p_y}{d} &amp; \frac{p_y^2 + f^2}{f} &amp; -\frac{p_x p_y}{f} &amp; -p_x<br>\end{bmatrix}</p><pre><code>$$</code></pre><ul><li><p>x 是待求解的6个运动参数。</p></li><li><p>b 是预测的光流向量。</p><p>$$<br>x &#x3D;</p></li></ul><p>\begin{bmatrix}<br>t_x \ t_y \ t_z \ \theta_x \ \theta_y \ \theta_z<br>\end{bmatrix},<br>\quad<br>b &#x3D;<br>\begin{bmatrix}<br>F_x \ F_y<br>\end{bmatrix}</p><pre><code>$$</code></pre><ul><li><p><strong>最小二乘求解</strong>：对于图像中的所有像素，系统是超定的。使用最小二乘法求解最优解</p><p>$$<br>x &#x3D; (A^\top A)^{-1} A^\top b<br>$$</p></li><li><p><strong>速度计算</strong>：将求得的相对位姿变化除以曝光时间 τ，即可得到瞬时速度 (ω,v)。</p></li><li><p><strong>端到端训练</strong>：由于最小二乘求解是可微分的，可以将最终的速度预测误差（公式11中的 L2​）反向传播，实现从输入图像到最终速度的端到端优化。</p><p>$$<br>L_2 &#x3D; \lambda_R | R - h_p(\hat{R}) |^2</p></li></ul><ul><li>\lambda_t | t - h_p(\hat{t}) |^2</li><li>L_1<br>$$</li></ul><h3 id="Direction-Disambiguation-方向歧义性解决"><a href="#Direction-Disambiguation-方向歧义性解决" class="headerlink" title="Direction Disambiguation (方向歧义性解决)"></a><strong>Direction Disambiguation (方向歧义性解决)</strong></h3><ul><li><p><strong>问题根源</strong>：运动模糊是时间对称的，无法区分正向和反向运动。</p></li><li><p><strong>解决方案</strong>：</p><ol><li><p>给定连续帧 ${l}<em>{i-1}$，${l}</em>{i}$，${l}<em>{i+1}$其中 ${l}</em>{i}$是模糊图像。</p></li><li><p>将预测的完整光流${F}<em>{i}$按时间比例缩放，得到短时间光流 ${F}</em>{i’}$,然后用 ${F}<em>{i’}$扭曲${l}</em>{i}$得到${l}_{i’}$</p><p>$$<br>F’_i &#x3D; \Delta t_f , F_i, \quad</p></li></ol></li></ul><p>I’_i &#x3D; \Phi(I_i; F’_i)<br>     $$</p><ol start="3"><li><p>计算两种可能方向（正向和反向）下的总光度误差 ${e}<em>{fw}$​ 和 ${e}</em>{bw}$(i-1，i，i+1)。</p><p>$$<br>P(I_1, I_2) &#x3D; \frac{1}{HW} \sum_{u&#x3D;0}^{H-1} \sum_{v&#x3D;0}^{W-1} \big| I_1(u,v) - I_2(u,v) \big| \tag {帧光度误差}<br>$$</p><p>$$<br>e_{fw} &#x3D; P(I_{i+1}, I’<em>i, fw) + P(I</em>{i-1}, I’_i, bw)<br>$$</p><p>$$<br>e_{bw} &#x3D; P(I_{i+1}, I’<em>i, bw) + P(I</em>{i-1}, I’_i, fw)<br>$$</p></li><li><p>选择误差更小的方向作为最终的运动方向。</p><p>$$<br>\omega, v &#x3D;</p></li></ol><p>\begin{cases}<br>\omega_{fw}, v_{fw}, &amp; \text{if } e_{fw} &lt; e_{bw} \<br>\omega_{bw}, v_{bw}, &amp; \text{otherwise}<br>\end{cases}<br>     $$</p><h2 id="数据集构建"><a href="#数据集构建" class="headerlink" title="数据集构建"></a>数据集构建</h2><h3 id="合成数据集"><a href="#合成数据集" class="headerlink" title="合成数据集"></a>合成数据集</h3><p><strong>模糊合成流程</strong>：</p><ol><li>选取一个真实图像 ${I}_{i}$。</li><li>使用<strong>RIFE</strong>插值模型，在 ${I}_{i}$ 和后续的 N 个真实帧之间生成多个虚拟帧，形成一个序列${I}$。</li><li>将序列 ${I}$转换到线性空间，取平均，再转回sRGB，得到模糊图像 IB​。</li></ol><p><strong>真值获取</strong>：</p><ul><li><p><strong>深度</strong>：使用PromptDA模型，结合第一个虚拟图像 I1ν​ 和ARKit稀疏深度，生成稠密深度图 D。</p></li><li><p><strong>光流</strong>：利用深度图 D，将 ${I}<em>{v1}$​ 中的所有像素反投影到3D空间，再投影到 ${I}</em>{vN}$，计算位移得到真值光流 F。</p></li><li><p><strong>规模</strong>：约12万训练样本，1.2万验证样本</p></li></ul><h3 id="真实数据集"><a href="#真实数据集" class="headerlink" title="真实数据集"></a>真实数据集</h3><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>为了评估模型的真实性能，作者在4个未见过的真实世界视频序列上进行了测试。评估的核心是相机的<strong>瞬时速度</strong>，因此需要精确的真值。</p><p>对于<strong>角速度</strong>（ω）的真值，直接采用了设备内置<strong>陀螺仪</strong>（gyroscope）的测量数据，这是最直接可靠的物理测量。对于<strong>线速度</strong>（v）的真值，由于没有直接的传感器，作者通过对<strong>ARKit</strong>系统估计出的相机位姿进行<strong>中心有限差分</strong>（centered finite-difference）计算来近似得到。</p><p>评价指标采用了各轴向的<strong>均方根误差</strong>（RMSE），单位分别为弧度每秒（rad&#x2F;s）和米每秒（m&#x2F;s）。作为对比的基线方法包括COLMAP、MASt3R和DROID-SLAM。由于这些方法本质上是估计多帧间的相对位姿而非瞬时速度，因此同样通过对它们输出的位姿序列进行有限差分来近似其速度估计，从而与本文方法进行公平比较。</p><h2 id="一些注意"><a href="#一些注意" class="headerlink" title="一些注意"></a>一些注意</h2><p>这篇论文虽然说“from a single motion-blurred image”，但其完整的方法流程（包括方向歧义解决）实际上<strong>隐含地假设了存在一个连续的视频流或至少能获取邻近帧</strong>。</p><p>例如系统正在实时接收视频帧。当检测到某一帧 ${I}<em>{i}$ 模糊时，它可以利用刚刚过去的 ${I}</em>{i-1}$ 和即将到来的 ${I}_{i+1}$来解决方向问题。</p>]]></content>
      
      
      <categories>
          
          <category> 2025ICCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动模糊 </tag>
            
            <tag> 运动估计 </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some python grammar</title>
      <link href="/2025/10/06/Some-python-grammar/"/>
      <url>/2025/10/06/Some-python-grammar/</url>
      
        <content type="html"><![CDATA[<p>这是一篇从C++算法代码的角度思考，如何速成python语法的文章，笔者由于之前需要通过一项python的算法测试，故编写了这篇文章，现在希望可以帮助大家</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 题目描述:# 第一行是一个整数 n，表示接下来有 n 行数据。# 接下来的 n 行，每行一个整数。n &#x3D; int(input())            # 先读取数据量 nfor i in range(n):          # 循环 n 次    data &#x3D; int(input())     # 每次读取一个整数    # 在这里处理 data...    print(data * 2)         # 示例：输出两倍# 读取一行中的两个整数 (用空格分隔)line &#x3D; input()              # 读取整行，例如 &quot;5 10&quot;parts &#x3D; line.split()        # 按空白字符分割，得到列表 [&#39;5&#39;, &#39;10&#39;]a &#x3D; int(parts[0])           # 转换第一个元素b &#x3D; int(parts[1])           # 转换第二个元素# 更简洁的写法 (常用！)a, b &#x3D; map(int, input().split())# 解释: #   input().split() -&gt; [&#39;5&#39;, &#39;10&#39;] (字符串列表)#   map(int, ...) -&gt; 将int函数应用到列表每个元素，得到一个map对象#   a, b &#x3D; ... -&gt; 序列解包，把map对象的前两个值分别赋给a和b# 读取一行k个整数k &#x3D; 3x, y, z &#x3D; map(int, input().split())  # 如果知道数量# 或者，如果数量不确定，存入列表numbers &#x3D; list(map(int, input().split())) # 得到 [5, 10, 3, 8] 这样的列表# 题目描述:# 第一行包含两个整数 n 和 m。# 接下来 n 行，每行 m 个整数，表示一个 n×m 的矩阵。# 读取第一行n, m &#x3D; map(int, input().split())# 初始化一个空列表来存储矩阵matrix &#x3D; []# 读取 n 行for i in range(n):    # 读取一行，并分割成 m 个整数，存入列表    row &#x3D; list(map(int, input().split()))    matrix.append(row)  # 将这一行添加到矩阵中# 现在 matrix 是一个二维列表，可以像 C++ 二维数组一样访问# 例如，matrix[0][0] 是左上角的元素# matrix[i][j] 是第 i+1 行第 j+1 列的元素# 示例：计算所有元素的和total &#x3D; 0for i in range(n):    for j in range(m):        total +&#x3D; matrix[i][j]print(total)print(1, 2, 3)           # 输出: 1 2 3 (默认空格分隔，换行结束)print(1, 2, 3, sep&#x3D;&#39;-&#39;)  # 输出: 1-2-3print(1, end&#x3D;&#39; &#39;)        # 输出: 1 (不换行，以空格结束)print(2)                 # 输出: 2 (换行)# 最终效果: 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Trick"><a href="#Trick" class="headerlink" title="Trick"></a>Trick</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">mid&#x3D;(l+r)&#x2F;&#x2F;2 #python不声明类型，&#x2F;可能出现浮点数，故&#x2F;&#x2F;为整数除法TreeNode(nums[mid])#__init__为构造函数，直接调用即可# 1. 导入必要的模块（如果需要）import sysfrom collections import deque# 4. 主函数：处理输入、调用算法、输出结果def main():    # 读取输入（根据题目要求）    try:        line &#x3D; input().strip()        # 假设输入是一行整数，如: [-10,-3,0,5,9]        # 去掉括号，分割，转整数        nums &#x3D; list(map(int, line.strip(&#39;[]&#39;).split(&#39;,&#39;))) if line.strip(&#39;[]&#39;) else []    except:        print(&quot;Invalid input&quot;)        return    # 创建 Solution 实例并调用方法    sol &#x3D; Solution()    root &#x3D; sol.sortedArrayToBST(nums)    # 输出结果（例如：层序遍历输出）    result &#x3D; level_order(root)   print(result)import sysdata &#x3D; []for line in sys.stdin:    data.append(list(map(int, line.split())))t &#x3D; int(input())  # 测试用例数for _ in range(t):    n &#x3D; int(input())    nums &#x3D; list(map(int, input().split()))    # 处理每组数据self.res &#x3D; []  # 实例变量，在方法内初始化，可以在其他方法调用#你将 ans 列表的引用添加到了 res 中。由于 ans 是一个可变对象，并且在整个递归过程中被反复修改（append 和 pop），#最终 res 中的所有元素都会指向同一个 ans 对象，其值为空（因为最后都 pop() 了），或者状态混乱res.append(ans[:])  # 使用切片复制列表res.append(ans.copy())        left&#x3D;bisect.bisect_left(nums,target)        right&#x3D;bisect.bisect_right(nums,target)#类似lower_bound和upper_bound    indices &#x3D; np.random.permutation(X.shape[0])np.random.permutation(100)：生成一个从 0 到 99 的整数的随机排列（打乱顺序）one_hot[np.arange(x.size), x] &#x3D; 1num,counts&#x3D;np.unique(y,return_counts&#x3D;True)    # 生成索引,注意不是arrange    indices &#x3D; np.arange(n_samples)    # 是否打乱    if shuffle:        np.random.shuffle(indices)            sampled_indices &#x3D; np.random.choice(indices, size&#x3D;n_samples, replace&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>train_indices = np.concatenate(folds[:i] + folds[i+1:])  # 其余合并为训练集#类似extend</code></pre><ul><li><code>input()</code>：读取一行输入，返回字符串。</li><li><code>split()</code>：按空白字符（空格、制表符、换行）分割字符串。</li><li><code>map(func, iterable)</code>：对列表中的每个元素应用函数（如 <code>int</code>）。</li><li><code>list()</code>：将 <code>map</code> 对象转为列表</li><li><code>n = int(input())  假如第一行的数字代表数据组个数</code></li><li><pre class=" language-language-pyhton"><code class="language-language-pyhton">folds = np.array_split(indices, 5)folds[0] = array([0, 1])      # 第0折：2个样本folds[1] = array([2, 3])      # 第1折：2个样本folds[2] = array([4, 5])      # 第2折：2个样本folds[3] = array([6, 7])      # 第3折：2个样本folds[4] = array([8, 9])      # 第4折：2个样本<pre class="line-numbers language-none"><code class="language-none">## DICT&#96;&#96;&#96;pythond &#x3D; &#123;&#125;d['key1'] &#x3D; 100           # 方式1：直接赋值（推荐）del d['key1']             # 删除键，不存在会报错 KeyErrord.pop('key2')             # 删除并返回值，不存在可设默认值 d.pop('key2', None)d['key1'] &#x3D; 999           # 直接赋值修改d.update(&#123;'key1': 888&#125;)   # 批量更新value &#x3D; d['key1']         # 获取值，key 不存在会报错value &#x3D; d.get('key1', -1) # 获取值，不存在返回默认值（推荐）'key1' in d               # 检查 key 是否存在，返回 True&#x2F;Falsed.keys()    # 所有键d.values()  # 所有值d.items()   # 所有键值对 (key, value)# 按 key 排序sorted_by_key &#x3D; dict(sorted(d.items(), key&#x3D;lambda x: x[0]))# 按 value 排序（从小到大）sorted_by_value &#x3D; dict(sorted(d.items(), key&#x3D;lambda x: x[1]))sorted_mp&#x3D;sorted(mp.items(),key&#x3D;lambda x:x[1],reverse&#x3D;True)#不转换为dict，因为dict不支持切片，直接用sorted可以转为list# 从大到小排序sorted_by_value_desc &#x3D; dict(sorted(d.items(), key&#x3D;lambda x: x[1], reverse&#x3D;True))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; set()           # 正确：创建空集合s &#x3D; &#123;1, 2, 3&#125;s.add(4)                  # 添加单个元素s.update([5, 6])          # 添加多个元素（可迭代对象）s.remove(4)               # 删除元素，不存在会报错s.discard(4)              # 删除元素，不存在也不报错s.pop()                   # 随机删除并返回一个元素（无序！）s.clear()                 #清空3 in s                    # 检查元素是否存在，O(1)s.issubset(other_set)     # 子集判断s.issuperset(other_set)   # 超集判断len(s)                    # 元素个数sorted_list &#x3D; sorted(s)           # 升序sorted_list_desc &#x3D; sorted(s, reverse&#x3D;True)  # 降序nums.sort(key&#x3D;lambda x: (x[0], -x[1]))#第一个升序，第二个降序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>部分</th><th>说明</th></tr></thead><tbody><tr><td><code>nums.sort()</code></td><td>对列表 <code>nums</code> <strong>原地排序</strong></td></tr><tr><td><code>key=</code></td><td>指定一个函数，告诉 Python <strong>按什么规则排序</strong></td></tr><tr><td><code>lambda x: ...</code></td><td>匿名函数，输入是列表中的每个元素 <code>x</code>，输出是一个“排序键”</td></tr><tr><td><code>(x[0], -x[1])</code></td><td>返回一个元组，作为排序的依据</td></tr></tbody></table><h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">dp &#x3D; [0] * (k + 1)#用list模拟数组stack &#x3D; []stack.append(1)stack.append(2)lst.remove(5)top &#x3D; stack.pop()         # 弹出最后一个元素，LIFOstack[-1] &#x3D; 99            # 修改栈顶元素top &#x3D; stack[-1]           # 查看栈顶（不删除）3 in stack                # 检查元素是否存在（O(n)）stack.sort()              # 原地排序（升序）stack.sort(reverse&#x3D;True)  # 原地降序sorted_stack &#x3D; sorted(stack)  # 返回新列表，不改变原栈lst &#x3D; [1, 2, 3, 2, 4]# 查找索引try:    index &#x3D; lst.index(2)    # 返回第一个 2 的索引：1    lst.pop(index)          # 删除该位置except ValueError:    print(&quot;元素不存在&quot;)lst &#x3D; [1, 2, 3, 4]# 删除最后一个lst.pop()        # 返回 4# 删除指定索引lst.pop(0)       # 删除第一个，返回 1# 或者用 del（不返回值）del lst[1]       # 删除索引 1 的元素nums[k:] &#x3D; nums[k:][::-1]#倒序（reverse）#使用nums[k:].reverse()会创建新数组，不改变原list，并且返回Nonesorted_nums &#x3D; sorted(nums, key&#x3D;lambda x: (x[0], -x[1]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from collections import dequeq &#x3D; deque()q.append(1)               # 从右边入队q.appendleft(0)           # 从左边入队（双端队列特性）front &#x3D; q.popleft()       # 从左边出队，FIFO，O(1)# q.pop()                 # 从右边出队，变成栈q[0] &#x3D; 99                 # 修改队首（支持索引访问）q[-1] &#x3D; 88                # 修改队尾orted_list &#x3D; sorted(q)   # 转为排序列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>操作</th><th><code>dict</code></th><th><code>set</code></th><th><code>list</code> (栈)</th><th><code>deque</code> (队列)</th></tr></thead><tbody><tr><td><strong>增</strong></td><td><code>d[k]=v</code>, <code>d.update()</code></td><td><code>s.add()</code>, <code>s.update()</code></td><td><code>lst.append()</code></td><td><code>q.append()</code>, <code>q.appendleft()</code></td></tr><tr><td><strong>删</strong></td><td><code>del d[k]</code>, <code>d.pop(k)</code></td><td><code>s.remove()</code>, <code>s.discard()</code></td><td><code>lst.pop()</code></td><td><code>q.popleft()</code></td></tr><tr><td><strong>改</strong></td><td><code>d[k] = new_v</code></td><td>先删后增</td><td><code>lst[-1] = new_val</code></td><td><code>q[0] = new_val</code></td></tr><tr><td><strong>查</strong></td><td><code>k in d</code>, <code>d.get(k)</code></td><td><code>x in s</code></td><td><code>lst[-1]</code>, <code>x in lst</code></td><td><code>q[0]</code>, <code>x in q</code></td></tr><tr><td><strong>排序</strong></td><td><code>dict(sorted(d.items()))</code></td><td><code>sorted(s)</code></td><td><code>lst.sort()</code></td><td><code>sorted(q)</code></td></tr></tbody></table><table><thead><tr><th>方法</th><th>行为</th><th>示例</th></tr></thead><tbody><tr><td><code>append(iterable)</code></td><td>把整个对象当作一个元素添加</td><td><code>q.append([1,2])</code> → <code>deque([[1,2]])</code></td></tr><tr><td><code>extend(iterable)</code></td><td>把可迭代对象的<strong>每个元素</strong>逐个添加</td><td><code>q.extend([1,2])</code> → <code>deque([1, 2])</code></td></tr></tbody></table><h2 id="FOR"><a href="#FOR" class="headerlink" title="FOR"></a>FOR</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i, num in enumerate(nums):  # 更简洁地遍历索引和for i, char in enumerate(s):s &#x3D; &quot;abc&quot;for char in s:    print(char)  # a, b, c# 带索引遍历for i, char in enumerate(s):    print(f&quot;&#123;i&#125;: &#123;char&#125;&quot;)# 保留索引不在 &#96;indices_to_remove&#96; 中的元素result &#x3D; [value for index, value in enumerate(data) if index not in indices_to_remove]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/10/06/hello-world/"/>
      <url>/2025/10/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
